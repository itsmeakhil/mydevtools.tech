"use client"

import * as React from "react"
import { toast } from "sonner"
import {
    collection,
    query,
    where,
    onSnapshot,
    addDoc,
    updateDoc,
    deleteDoc,
    doc,
    serverTimestamp,
    getDocs,
    writeBatch
} from "firebase/firestore"
import { db, auth } from "@/database/firebase"
import { useAuthState } from "react-firebase-hooks/auth"

export interface EnvironmentVariable {
    id: string
    key: string
    value: string
    enabled: boolean
}

export interface Environment {
    id: string
    name: string
    variables: EnvironmentVariable[]
    userId?: string
}

const STORAGE_KEY = "api-client-environments"
const ACTIVE_ENV_KEY = "api-client-active-environment"

export function useEnvironments() {
    const [user, loading] = useAuthState(auth)
    const [environments, setEnvironments] = React.useState<Environment[]>([])
    const [activeEnvId, setActiveEnvId] = React.useState<string | null>(null)
    const [isLoading, setIsLoading] = React.useState(true)

    // Load environments from Firestore
    React.useEffect(() => {
        if (loading) return
        if (!user) {
            setEnvironments([])
            setIsLoading(false)
            return
        }

        const q = query(
            collection(db, "api_environments"),
            where("userId", "==", user.uid)
        )

        const unsubscribe = onSnapshot(q, (snapshot) => {
            const envs = snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            })) as Environment[]

            // Sort by name
            envs.sort((a, b) => a.name.localeCompare(b.name))

            setEnvironments(envs)
            setIsLoading(false)
        }, (error) => {
            console.error("Error fetching environments:", error)
            toast.error("Failed to load environments")
            setIsLoading(false)
        })

        return () => unsubscribe()
    }, [user, loading])

    // Migration logic: LocalStorage -> Firestore
    React.useEffect(() => {
        const migrateData = async () => {
            if (loading || !user || !isLoading) return

            const stored = localStorage.getItem(STORAGE_KEY)
            if (!stored) return

            // Check if we already have data in Firestore
            const q = query(collection(db, "api_environments"), where("userId", "==", user.uid))
            const snapshot = await getDocs(q)

            if (snapshot.empty) {
                try {
                    const localEnvironments: Environment[] = JSON.parse(stored)
                    if (localEnvironments.length > 0) {
                        const batch = writeBatch(db)
                        localEnvironments.forEach(env => {
                            // Create new doc ref
                            const newDocRef = doc(collection(db, "api_environments"))
                            // We don't use the old ID as the doc ID to let Firestore auto-generate, 
                            // but we might want to preserve it if it's referenced elsewhere?
                            // The activeEnvId references it. 
                            // If we change IDs, we break the active selection.
                            // Let's try to use the existing ID if it's a valid string, or map it.
                            // Actually, let's just create new docs and if the active one matches, we're good.
                            // Wait, if we change IDs, activeEnvId (stored locally) won't match.
                            // We should probably update activeEnvId if we can map them.
                            // Simpler: Just use the old ID as the doc ID if possible? 
                            // Firestore IDs are strings. 

                            // Let's just generate new IDs for cleanliness and reset active env if needed.
                            // Or better, try to keep the ID if it looks like a UUID.

                            batch.set(newDocRef, {
                                ...env,
                                userId: user.uid,
                                createdAt: serverTimestamp(),
                                updatedAt: serverTimestamp()
                            })
                        })
                        await batch.commit()
                        toast.success("Migrated local environments to cloud")
                        localStorage.removeItem(STORAGE_KEY)
                        // We might lose active env selection if IDs change, but that's acceptable for a one-time migration.
                        // Actually, since we are reading 'stored' which has the IDs, and we are creating NEW docs with NEW IDs (auto-generated by doc()),
                        // the IDs WILL change.
                        // If we want to preserve IDs, we should use setDoc with specific ID.
                        // But local IDs might be UUIDs, which are fine for Firestore.
                    }
                } catch (e) {
                    console.error("Migration failed", e)
                }
            }
        }

        if (!loading && user) {
            migrateData()
        }
    }, [user, loading, isLoading])

    // Load active env from local storage
    React.useEffect(() => {
        const storedActive = localStorage.getItem(ACTIVE_ENV_KEY)
        if (storedActive) {
            setActiveEnvId(storedActive)
        }
    }, [])

    // Persist active env to local storage
    React.useEffect(() => {
        if (activeEnvId) {
            localStorage.setItem(ACTIVE_ENV_KEY, activeEnvId)
        } else {
            localStorage.removeItem(ACTIVE_ENV_KEY)
        }
    }, [activeEnvId])

    const addEnvironment = async (name: string) => {
        if (!user) return ""

        try {
            const docRef = await addDoc(collection(db, "api_environments"), {
                name,
                variables: [],
                userId: user.uid,
                createdAt: serverTimestamp(),
                updatedAt: serverTimestamp()
            })
            toast.success("Environment created")
            return docRef.id
        } catch (e) {
            console.error("Error creating environment", e)
            toast.error("Failed to create environment")
            return ""
        }
    }

    const updateEnvironment = async (id: string, updates: Partial<Environment>) => {
        if (!user) return

        try {
            const envRef = doc(db, "api_environments", id)
            await updateDoc(envRef, {
                ...updates,
                updatedAt: serverTimestamp()
            })
        } catch (e) {
            console.error("Error updating environment", e)
            toast.error("Failed to update environment")
        }
    }

    const deleteEnvironment = async (id: string) => {
        if (!user) return

        try {
            await deleteDoc(doc(db, "api_environments", id))
            if (activeEnvId === id) {
                setActiveEnvId(null)
            }
            toast.success("Environment deleted")
        } catch (e) {
            console.error("Error deleting environment", e)
            toast.error("Failed to delete environment")
        }
    }

    const getActiveVariables = (): Record<string, string> => {
        if (!activeEnvId) return {}
        const env = environments.find(e => e.id === activeEnvId)
        if (!env) return {}

        return env.variables.reduce((acc, v) => {
            if (v.enabled && v.key) {
                acc[v.key] = v.value
            }
            return acc
        }, {} as Record<string, string>)
    }

    const substituteVariables = (text: string): string => {
        if (!text) return text
        const variables = getActiveVariables()
        return text.replace(/\{\{(.+?)\}\}/g, (match, key) => {
            return variables[key.trim()] || match
        })
    }

    return {
        environments,
        activeEnvId,
        setActiveEnvId,
        addEnvironment,
        updateEnvironment,
        deleteEnvironment,
        substituteVariables,
        isLoading
    }
}
